---
layout: single
title: Project Euler Problem 12 in F#
date: 2010-10-27 14:40:54.000000000 +01:00
type: post
published: true
status: publish
categories:
- ".NET"
- F#
tags:
- algorithm
- F#
- functional
meta:
  _edit_last: '1'
  dsq_thread_id: '162751515'
  _wp_old_slug: ''
  _aioseop_title: Project Euler Problem 12 in F#
  _aioseop_description: A solution to Project Euler Problem 12 in F#
  _aioseop_keywords: f#, fsharp, euler, algorithm, triangle numbers
---
<p>After a brief digression with an <a href="/2010/10/01/a-rpn-calculator-in-f/">RPN Calculator</a>, 
here we are again with a new Project Euler problem:</p>
<blockquote><p>The sequence of triangle numbers is generated by adding the natural numbers.</p>
<p>So the 7^(th) triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.</p>
<p>The first ten terms would be: <br />
		1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...</p>
<p>Let us list the factors of the first seven triangle numbers:</p>
<p>
	1: 1 <br />
	3: 1,3 <br />
	6: 1,2,3,6 <br />
	10: 1,2,5,10 <br />
	15: 1,3,5,15 <br />
	21: 1,3,7,21 <br />
	28: 1,2,4,7,14,28</p>
<p>We can see that 28 is the first triangle number to have over five divisors.</p>
<p>What is the value of the first triangle number to have over five hundred divisors?</p>
</blockquote>
<p>Again, this problem is relatively simple to solve and it's about finding an algorithm with decent performances.</p>
<h2>The naive (slow) solution</h2>

{% highlight F# %}
#light

let triangles =
    Seq.unfold (fun (acc, state) -> Some (acc, (state + acc, state + 1))) (0, 1)
    |> Seq.skip 1 // skip the initial 0

let divides y x =
    x % y = 0

let rec all_factors_slow_rec n i acc =
    match i with
        | 1 -> 1::acc
        | x when divides x n -> all_factors_slow_rec n (x-1) (x::acc) 
        | _ -> all_factors_slow_rec n (i-1) acc
        
let all_factors_slow n =
    all_factors_slow_rec n n []

let find_index m =
    triangles
    |> Seq.map all_factors_slow
    |> Seq.tryFindIndex (fun x -> List.length x >= m)

let resolve_problem_12 =
    let i = find_index 500
    match i with
        | None -> failwith "Cannot resolve problem"
        | Some(i) ->
            let list = triangles |> Seq.take (i+1) |> List.ofSeq
            list.[i]
{% endhighlight %}

<ul>
<li>Considering that triangle numbers are a mathematical sequence defined as follows: <br />
		$$t_n = t_{n-1} + n$$ where \(t_0 = 0\), then we easily define an F# sequence that yields triangle numbers using <code>Seq.unfold.</code></li>
<li>We then define a function <code>all_factors_slow_rec</code> to calculate all factors (not just primes) of a given number. 
The slow solution presented in the first listing starts from a number \(n\) and then by brute force tries all the numbers 
down to \(1\) as a candidate factor.</li>
<li>Once we have these two pieces together, it is just a matter of enumerating all possible triangle numbers, 
    finding for each their factors (using <code>Seq.map</code>) and finally determining the first triangle number having at least 
    500 factors (using <code>Seq.tryFindIndex</code>). If \(i\) is the index of such a number, 
    we then go back to the original sequence of triangles to extract the \(i^{th}\) element.</li>
</ul>
<h2>An improved version</h2>

{% highlight F# %}
let divides y x =
    x % y = 0

let triangles =
    Seq.unfold (fun (acc, state) -> Some (acc, (state + acc, state + 1))) (0, 1)
    |> Seq.skip 1 // skip the initial 0

let rec all_factors_quick_rec n i factors =
    if divides i n then
        let y = n / i
        if (i < y) then
            all_factors_quick_rec n (i + 1) (i::y::factors)
        elif (i = y) then
            // we have reached the square root value
            i::factors
        else
            factors
    elif i > int (sqrt (float n)) then
        // we are beyond the square root value
        factors
    else
        // try with the next number
        all_factors_quick_rec n (i + 1) factors
        
let all_factors_quick n =
    all_factors_quick_rec n 1 []

let find_index m =
    triangles
    |> Seq.map all_factors_quick
    |> Seq.tryFindIndex (fun x -> List.length x >= m)

let resolve_problem_12 =
    let i = find_index 500
        match i with
        | None -> failwith "Cannot resolve problem"
        | Some(i) ->
            let list = triangles |> Seq.take (i+1) |> List.ofSeq
            list.[i]

{% endhighlight %}

<p>The bottleneck of the previous solution is the naive approach to find all the factors of a number. 
    On my machines this solution takes several minutes.</p>
<p>Better performances can be obtained observing that in order to determine 
    all the factors of a number we don't have try <em>all</em> smaller numbers.
     As a matter of fact, the following is true (considering <em>n</em> the number to be factorized):</p>
<ul>
<li>if \(n / x = y\), obviously both \(x\) and \(y\) are factors, 
so I don't have to probe <em>y</em> anymore</li>
<li>If I start probing from 2 going up, I can stop probing when I have reached \(\sqrt n\). 
    In fact, any number bigger than \(\sqrt n\) must have been already found probing a smaller number.</li>
</ul>
<p>Suppose for example that we have to factor the number 36 (one of the triangle numbers):</p>
<ul>
<li>1 is always a factor -> factors = {<strong>1</strong>, <strong>36</strong>}</li>
<li>2 * 18 = 36 -> factors = {1, 36, <strong>2</strong>, <strong>18</strong>}</li>
<li>3 * 12 = 36 -> factors = {1, 36, 2, 18, <strong>3</strong>, <strong>12</strong> }</li>
<li>4 * 9 = 36 -> factors = {1, 36, 2, 18, 3, 12, <strong>4</strong>, <strong>9</strong>}</li>
<li>5 does not divide -> factors = {1, 36, 2, 18, 3, 12, 4, 9}</li>
<li>6 * 6 = 36 -> factors = {1, 36, 2, 18, 3, 12, 4, 9, <strong>6</strong>}</li>
</ul>
<p>We can stop here because if 7 divided 36 evenly, we would have already found a number <em>x</em> < 6 such that 7 * <em>x</em> = 36.</p>
<p>The improved version runs on my machine in less than 1 second.</p>