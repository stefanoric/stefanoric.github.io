---
layout: single
title: Project Euler Problem 1 and 2 in F#
date: 2010-06-14 13:30:45.000000000 +01:00
type: post
published: true
status: publish
categories:
- ".NET"
- F#
tags:
- algorithm
- F#
meta:
  _edit_last: '1'
  ks_metadata: a:7:{s:4:"lang";s:2:"en";s:8:"keywords";s:49:"fsharp,f#,algorithm,sequence,.NET,Euler,fibonacci";s:19:"keywords_autoupdate";s:1:"0";s:11:"description";s:65:"Two
    possible solutions in F# for Project Euler problems 1 and 2 .";s:22:"description_autoupdate";s:1:"0";s:5:"title";s:35:"Project
    Euler Problem 1 and 2 in F#";s:6:"robots";s:12:"index,follow";}
  _aioseop_title: Project Euler Problem 1 and 2 in F#
  _aioseop_description: fsharp f# algorithm sequence .NET Euler fibonacci
  dsq_thread_id: '149554688'
  _aioseop_keywords: fsharp, f#, algorithm, sequence, .NET, Euler, fibonacci
  wpsd_autopost: '1'
---
<p>In my journey to learn F#, I have recently discovered the <a href="http://projecteuler.net">Project Euler</a> site,
which is a wonderful collection of small algorithmic problems which you can solve in 
your favorite programming language.</p>
<p>This is the kind of excercise I needed to get my feet wet with F# after reading about it. 
  So I started with the first two problems listed on the site.</p>
<p>They both deal with sequence of numbers. Having a procedural/object-oriented mindset, 
  I have scratched my head a few times in order to find a declarative solution true to the 
  spirit of a functional program. Everything has become clearer after I've dug some 
  more into the <a href="http://msdn.microsoft.com/en-us/library/dd233209.aspx">F# Sequences</a>.</p>
<h2>Problem 1</h2>
<blockquote><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p>
<p>Find the sum of all the multiples of 3 or 5 below 1000.</p></blockquote>
<p>This is my solution to it:</p>
<pre class="brush: fsharp">
# light 
let test = 1     
    |> Seq.unfold (fun x -> Some(x, x+1))
    |> Seq.takeWhile (fun x -> x < 1000)           
    |> Seq.filter ( fun x -> x % 3 = 0 || x % 5 = 0)
    |> Seq.sum;;
</pre>
<h2>Problem 2</h2>
<blockquote><p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p>
<p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</p>
<p>Find the sum of all the even-valued terms in the sequence which do not exceed four million.</p></blockquote>
<p>Here follows my solution:</p>

{% highlight F# %}
let fibonacci_sequence = Seq.unfold (fun (a, b) -> Some(a, (b, a+b))) (0,1)
    |> Seq.takeWhile(fun x -> x <= 4000000) 
    |> Seq.filter(fun x -> x % 2 = 0)
    |> Seq.sum
{% endhighlight %}

<p>A few comments:</p>
<ul>
<li>Here I am using the <code>filter</code> method defined on sequences to stop<br />
the sequence itself at 4 million, therefore I can get by with plain integers.
Normally you would want to use <a href="http://msdn.microsoft.com/en-us/library/ee620695(v=VS.100).aspx">BigInteger</a>s 
for sequences where you'd expect to need handling large numbers.</li>
<li>One of my first attempts to this problem did not have the <code>Seq.filter</code> part.
I only had the <code>takeWhile</code> like the following:</li>

{% highlight F# %}
Seq.takeWhile(fun x -> x % 2 = 0 &amp;&amp; x <= 4000000) 
{% endhighlight %}

<p>Unfortunately, this does not work since the <code>takeWhile</code> will interrupt 
the sequence as soon as it satisfies the first condition (<code>x % 2 = 0</code>); in other words, 
it yields a sequence consisting only of the value 0, which looked somehow 
counterintuitive to me at first.
</ul>
<p>If you are also taking your first steps with F#, you might want to have a look to 
  the <a href="/2010/05/31/best-resources-to-learn-f/">best resources to learn it</a>.</p>